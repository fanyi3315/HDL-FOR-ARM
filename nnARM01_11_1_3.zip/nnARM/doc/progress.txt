------------------------------------------------------------------------
2001 3 22
	经过5天的调试，存控已经可以使用，下面的工作是将流水线中的与存控接口的代码移出来，成为cache控制器的一部分，从而为流水线的开发减轻负担。
------------------------------------------------------------------------


------------------------------------------------------------------------
2001 3 23
1、	正在添加对跳转指令的支持，但是，由于MEM和IF的访存冲突，使得在两者进入访存之前必须先判断，现在进入IF的判断代码已经完成，但是它总是占着访存资源不放，当branch到达mem时，无法得到访存资源，从而无法跳转，而且mem的访存判断代码还没有完成，存为nnARM01_03_23_1.zip
2、	所有的访存冲突控制代码已经完成，流水线站的走停也解决了。但还有以下问题，首先，访存没有区分读写，其次，branch读出的指令没有干什么用，还有，本站的指令已经移到下一站了，本站的寄存器怎么办,他是由前一站写的，
3、	已经可以连续跳转两次，但是第二次跳转以后状态不定，存为nnARM01_03_24_final.zip
------------------------------------------------------------------------


------------------------------------------------------------------------
2001 3 24
1、	已经可以正常的运行连续的跳转指令，存为nnARM01_03_24_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 3
1、重新安排系统结构，构造了指令预取部件InstructionPreFetch以克服cache的单周期延迟，目前仅仅支持读操作，还没有访存和访存时的等待，存为nnARM01_04_03_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 5
1、已经有了指令cache InstructionCacheController，256 byte ,4 section ,4 - way association,4 word per way，但是存控好像又不对了，存为nnARM01_04_05_1.zip
2、经过了改正，已经可以处理完全顺序的访存，随机地址也能正确处理，存为nnARM01_04_05_2.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 6
1、在昨天的基础上加入了显示语句，可以更清楚的看到访存的过程，然后加入了prefetch中对前向cache块的预取，存为nnARM01_04_06_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 7
1、加入了寄存器文件，以及寄存器文件的测试文件，运行正常存为nnARM01_04_07_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 9
1、加入了Decoder,ALUWraper,ALUComb,Arbitrator等，还没有通过测试。另外仍有以下功能没有实现：
	Wraper还不能读WriteBus上传送的结果
	Decoder还不能清除已完成指令的重定向
存为nnARM01_04_09_2.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 15
1、写了一个星期的文档，今天终于又加入了一个桶形移位器BarrelShift，及其测试代码，存为nnARM01_04_15_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 16
1、又有了补码产生器complementary，用于实现减法。存为nnARM01_04_16_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 17
1、完成了adder和全功能的ALU。存为nnARM01_04_17_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 19
1、重新整理互联，decoder_ARM中加了shifttype、shiftcount、thirdread，但还没有实现逻辑
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 20
1、整理好并实现了decoder_ARM,存为nnARM01_04_20_1.zip
2、整理好pipeline，存为nnARM01_04_20_2.zip
3、实现了三读一写的寄存器文件，存为nnARM01_04_20_3.zip
4、完全连好了，但是vcs编译未过，存为nnARM01_04_20_4.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 22
1、编译通过，存为nnARM01_04_22_1.zip，但是存在以下问题，
		1.当某一comp-entr在时钟前沿n完成计算并将结果打入writeresult,而后decode的指令要用到其结果，那么不管他在n+1前沿进入到那个comp-entr，他都无法得到他希望的结果，因为在n和n+1之间已经完成了写操作。
		2.无法通知decoder操作完成
		3.pc应组织到reg file中
		4.mem应该放到那里。
		5.redorder还没有实现
		6.4个标志位怎样处理
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 23
1.问题3解决，存为nnARM01_04_23_1.zip。
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 26
1、终于重新整理完了整个代码，修正了一些错误，存为nnARM01_4_26_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 27
1、将整个寄存器文件加大为32个寄存器，其中前31个是通用的，后面的一个是用于结果连接的。存为nnARM01_04_27_1.zip
2、对于问题1的解决，可以在readbus和writebus之间建立通道，用三态门控制，如果decode时发现线上正在传输需要的结果，可以从writebus到readbus打通。

必须注意以下问题
1、decoder_ARM中必须还要包含以下功能逻辑，输入写总线的使能信号以及 compentry还有目标寄存器号，decoder应该判断是否接受该结果进入寄存器文件，并从新产生使能信号。
2、从某一操作完成，到写入寄存器并清除map，这一段时间发射的指令无法得到需要的结果。

剩余的问题：
4 22 问题 4 5 6以及4 27 问题2
存为nnARM01_04_27_2.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 4 29
1、终于解决4 27问题2，存为nnARM01_04_29_1.zip
-------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 5 2
1、发现tomasulo结构我还不太了解，无法细化，只好先实现一个简单的流水线，包含link,只有最简单的alu指令，还没有branch和memory
存为sARM01_05_02_1.zip
---------------------------------------------------------------------------

------------------------------------------------------------------------
2001 5 5
1、完成一个不可综合的数据cache描述，还没有通过错误检查。存为sARM01_05_05_1.zip.下面的工作就是
	1、修正流水线，以包含对WB的forward的支持
	2、修改存控或者加一个mux以支持DCache的访存请求，
	3、增加访存指令。
2、添加了load指令，但是发现需要增加一个simple 线程，如今只有alu的线程接口完成，其他还没有.存为sARM01_05_05_2.zip
--------------------------------------------------------------------------

-------------------------------------------------------------------------
2001 5 6
1、完成了双线程结构，并将wb的功能移到mem中，同时，修正了can go和enable/valid的功能：
	1、当can go为0时，不能走，
	2、否则valid表示是否是一个泡，即否是一个合法指令，
	3、forwarding时，仍然只看目标寄存器，而不必看是否合法，因为当不合法时将输出linkregister

存为sARM01_05_06_1.zip
----------------------------------------------------------------------

-----------------------------------------------------------------------
2001 5 7
1、修正了所错误，并开始书写memorymux，存为sARM01_05_07_1.zip
------------------------------------------------------------------------

-----------------------------------------------------------------------
2001 5 11
1、将data memory独立出来，让data cache独立访问data memory，同时在mem中增加了访问datacache的接口，并修正了所有的语法错误，存为sARM01_05_11_1.zip
-----------------------------------------------------------------------

-----------------------------------------------------------------------
2001 5 13
1、datacache controller不能变换状态，当在时钟前沿看到访问使能时。存为sARM01_05_13_1.zip
-----------------------------------------------------------------------


-----------------------------------------------------------------------
2001 5 14
1、datacachecontroller之所以不能运行是因为always @(posedge clock or negedge reset)中if(reset==1'b1)以至于每次都是初始化，改成1'b0后就一切ok
load指令运行正常。
存为sARM01_05_14_1.zip
2、增加了load simple微操作，存为sARM01_05_14_2.zip
目前的问题是仍然不能区分byte和word。
3、完整的load支持，存为sARM01_05_14_3.zip
-----------------------------------------------------------------------

-------------------------------------------------------------------------
2001 5 15
1、正在添加store，只剩下mem stage中对各种store微操作的支持还没有写，存为sARM01_05_15_1.zip
-------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 16
1、已经可以支持word store，byte store还没有，下午再测，存为sARM01_05_16_1.zip
	mem中由于到datacache的数据总线是双向的，所以必须有一个暂存以及一个输出控制，原来的版本只支持load，所以该处的错误没有暴露出来，应该是当CanOutputToDataBus==1'b1时才输出tmpDataBus，平时输出z，而错误为少了==1'b1，改正后全对
2、改变了寄存器的组织结构，根据不同的处理机模式给出不同的reg bank，还创建了psr模块专门用于SPSR和CPSR。没有进行错误检查存为sARM01_05_16_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 17
1、正在添加对条件码的支持，已经加到了alushell，但是还没有将运算的状态结果输出，存为sARM01_05_17_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 18
1、已经完成了各个模块内部的更改，但是还没有对nnARM顶层模块的互联，存为sARM01_05_18_1.zip
2、改到了nnarm中的mem，没有完成的部分标以()
3、下午重新开始工作，改完后还没有查错，存为sARM01_05_18_2.zip
4、查完错，存为sARM01_05_18_3.zip,肯定还存在敏感表不完全的问题
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 19
1、解决了敏感表不完整的问题，存为sARM01_05_19_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 20
1、加入对MRS、MSRReg的支持，存为sARM01_05_20_1.zip,但是还没有查错
2、支持全部MSR和MRS，查完错，存为sARM01_05_20_2.zip.
3、已经支持branch，但是对于使用非branch指令修改pc的情况还没有处理，使用pc做源操作数的情况下不能forward，存为sARM01_05_20_3.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 21
1、现在存在以下问题：
	1、pc做源操作数时不能forward，
	2、pc做目的操作数时必须清除前面的所有指令
	3、当某一寄存器的值在某一thread中直到mem结束才知道(比如load)，此时必须使其后的指令等待直到可以forward
2、解决了问题1，对于alu/load/store中的base register为pc的情况，将与指令一同到达decoder的地址发到LeftReadBus上作为立即数。防止forward，存为sARM01_05_21_1.zip
3、pc做目的操作数时，除了load之外都已经处理，还有以下问题，首先mem修改pc时应清除自身，还应该通知alu和if，
4、已经完全处理了问题2，包括load to pc，使用alumisc[7]作为mem stage要改写pc的标志，alumisc[6]作为alu stage要改写pc的标志，所有改写pc的alu指令都等同于branch，经过查错后存为sARM01_05_21_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 22
1、解决了问题3，可以等待一个周期，在alu中生成一个空泡，当mem中的operation等待接过时，整个流水线停顿并等待该结果，直到结果到来并forward，没有经过错误检查，存为sARM01_05_22_1.zip
2、改正了一个错误，当decoder遇到一个alu指令时，仅当写pc时可以将alumisc[7]设为1，而原来忽略了。存为sARM01_05_22_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 23
1、加入对乘法和乘加的支持，没有经过错误检查，存为sARM01_05_23_1.zip
2、改完错，存为sARM01_05_23_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001  5 24
1、增加对使用pc做源操作数的支持，由于在编译时考虑了当前pc和当前指令pc之间的差别(前者比后者提前8或12个字节)，所以不能使用当前指令pc做运算，经过测试，branch正常，但是以pc为目的的alu指令(也就是子程序返回还不对)。另外，应当将data和instruction内存都用相同的程序初始化。还有，汇编.s文件时必须将起始地址放到1M以内以便测试，因为我的存控只有1M。存为sARM01_05_24_1.zip
2、改正了以上问题，原因是在IF中给出下一条指令的地址时是用pc加上4，但是pc是用于取下一条指令的，所以只需直接输出pc即可，存为sARM01_05_24_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 25
1、发现一个问题，当branch时，如果if正在等待prefetch，则会导致branch给出的pc更新信号丢失。另外改正了一个敏感表的问题，存为sARM01_05_25_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 28
1/重新书写了IF模块，使得当branch时的更新pc信号直接进入IF的寄存器，不再受到prefetchwait的影响，对于非branch的情况则与从前相同，由于prefetch在miss时自己记录了miss地址，所以可以在没有得到完成load的情况下给出新地址。但是又发现新问题，CMP应当是不回写减法结果的，存为sARM01_05_28_1.zip
2/改写decoder，因为有些指令不写reg，如CMP，而decoder只在对alu段的信号中考虑了这一点，并没有在mem段的信号中考虑这一点，所以改正后存为sARM01_05_28_2.zip，但是load什么都没有load近来，看看怎么回事
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 5 29
1/终于找到了datacache的问题，对于PrevAccess和ReplaceEntry，由于都是存储器类型，所以应该是元素宽度为[1:0]，个数为[3:0]，而不是[1:0]，改正后存为sARM01_05_29_1.zip，但是还有问题，最后一次load还是不行。
2/终于找到了load不进来的问题,主要是因为read in和write back结束后,没有修改tag,导致总是不能match up,不停的重新access,无法得到结果.修正后存为sARM01_05_29_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 5
1/为了运行elf文件,将pc初始地址改为0x8000,而SDT的linker中给出的代码段基地址为0x8000,数据段地址为0x0000,存为sARM01_06_05_1.zip
指令cache出了问题
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 6
1/不是cache出了问题,将prefetchbuffer中FetchAddress的初始化改为用pc,加入了为fft专门写的benchmark.
发现一个问题:当作cmp时,armulator不会有carry,但是nnARM有carry.在作减法时什么时候会和不会carry
问题的答案是:当作减法时,结果为负时不carry,当非负时carry
改动:1 减法的carry值等于加法器carry的反
2 将乘法独立出来单独由一个assign完成
存为sARM01_06_06_2.zip

改动decoder使其在碰到从mem forward的情况时结束发射,使得插入一个bulk.
data cache中的dirty和valid等用4位来寻址,也就是有16个,现在却用replace entry来寻址,也就是用2位寻址,故不行.
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 7
1/改动了昨天最后一个问题,又发现了新的问题,出了ALU和msr之外,应该不会有什么指令改变cpsr.看看文档吧
问题解决了,不是因为decoder有错,而是因为MEM忘记处理MEMPSRType_WriteConditionCode,加上
在cachecontroller中的writeback状态下,所有的地址生成都应该用WBAddress,但是发现有用RIAddress,改正.
存为sARM01_06_07_1.zip
又改正一个问题,writeback时地址生成有错,原来用replacecontent,现在改用replaceentry来寻址.
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 8
1/又进行了多个测试,都没有问题,存为sARM01_06_08_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 9
1/又发现问题,ALUComb中的带carry的加减法没有真正使用carry.而是定为1'b1.
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 11
1修改ALUComb中的带carry的加减操作,使之可以使用上一条指令的carry.存为sARM01_06_11_1.zip
2增加了ALUShell中和nnARM中对上一条指令的carry的支持
在测试jump时有问题,cmp中似乎减法不应该对carry求反,
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 12
1改正昨天问题,又发现新问题,对于不带s标志的alu指令仍然设置了cpsr,原因是在decoder处理时只给出了有s时的情况,而没有s时会使用前面设的值,而在前面的两种情况中都毫无理由的设置了psrthread的微操作.改正后运行
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 14
1增加了对SWI的支持，但是还没有输出状态转换信号到两个寄存器文件，而且还没有差错，存为sARM01_06_14_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6 15
1 输出状态信号到寄存器文件并查错，存为sARM01_06_15_1.zip
2 调试成功，存为sARM01_06_15_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 6.27
1 改正了一个小错误，mul的形参是33和32位的，但是实参是31位的，改正之，可以综合。存在以下问题：
	1	barrelshifter 的out_carry是有用的，但是没有驱动	ok
	2	没有按照arm7vc.pdf中对于flags的设置进行设置	ok
	3	据说还有一个latch在alucomb中。
	4	对于shift，还有reg作移位量时的特殊情况			
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 3
1 barrel shift中的out_carry有了驱动，存为sARM01_07_03_1.zip
2 解决了6 27的问题1 2, 问题3已经发问，问题4还没有解决，存为sARM01_07_03_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 4
1	除了问题3还没有解决外，全部ok,但是还没有测试，存为sARM01_07_04_1.zip
2	进行测试，发现以下问题，RRX只发生在ope2是reg，而且shift count为imm时，改正后存为sARM01_07_04_2.zip
3	经过完全测试和整理，得到可以跑全部testbench的sARM01_07_04_3.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 6
1	解决了所有的综合问题，存为sARM01_07_06_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 11
1	加法器改为一级，存为sARM01_07_11_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 12
1	Jerry_Hsu发现SecondWriteBus重复定义，删去，并存为sARM01_07_12_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 17
1	修改和注释Thumb_2_nnARM.v,存为sARM01_07_17_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 19
1	正在添加Thumb支持，已经到了Decoder_ARM中对于BX的处理，还要干三件事情
	1	添加对ALUPSRType_ModifyThumbState的支持			ok
	2	继续处理PC relatvie的问题				ok
	3	处理因为Thumb造成的不同语义，如condition 和uncondition branch中对于off的处理	ok
	
	存为sARM01_07_19_1.zip
	
2	完成以上改进，存为sARM01_07_19_2.zip，但是还有以下问题
	1	load address的PC+4要清bit 1
	2	pc relative load的PC+4也要清bit 1
	
3	解决以上问题，存为sARM01_07_19_3.zip
4	改正错误，可以运行Thumb，但是仍然不支持long branch with link,存为sARM01_07_19_4.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 20
1	已经支持long branch with link, 但是LR的问题还没有解决，存为sARM01_07_20_1.zip
2	解决了LR的问题，存为sARM01_07_20_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 23
1	去掉几个include，还有在InstructionPrefetch中防止地址为Z。存为sARM01_07_23_1.zip
2	将$time()的括号去掉，得到sARM01_07_23_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 28
1	关于CPSR和SPSR的新鲜度， 有于他们很有可能在流水线中被更改，所以所有使用CPSR的地方（寄存器文件，中断）都应该使用流水线中的最新CPSR和SPSR,而流水线最好在ALU结束时输出CPSR和SPSR的最新版本，不管当前是什么指令。这样就可以一直使用alu末端的CPSR，
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 7 30
1	改正了7月28的问题，还没有测试，存为sARM01_07_30_1.zip
2	经过测试，存为sARM01_07_30_2.zip
3	还有一个问题，当有跳转时，必须清除decoder中的状态
	ALUMisc[8]转义为exception
	ALUMisc[13:9]为exception state
	流水线中必须制定可不可以改变cpsr的规则，

4	完成了中断的处理，但是还没有改正3的问题，存为sARM01_07_30_3.zip
5	终于可以跑所有的以前的例子了，但是还没有找到其他的可以支持SWI和中断处理的例子，存为sARM01_07_30_4.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 8 27
1	完成了最普通的情况下的LDM down。存为sARM01_08_27_1.zip,ALUMisc[14]为delay branch,ALUMisc[15]为store delay branch target
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 8 28
1	在昨天的基础上加入了alushell和mem stage的支持
	发现一个问题，中断不理会整个流水线的状态，直接进入，会导致正在译码的指令的中断，应该先判断当前译码指令是否已经完成。
	改完错，存为sARM01_08_28_1.zip
	还有一个问题，当load pc时，应该向字或者半字靠齐
2	终于可以load进来了，但是不停的进入r7和r6,why?  存为sARM01_08_28_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 8 29
1	终于可以完成包含pc在内的ldm，但是还需要考虑thumb对pc的影响,存为sARM01_08_29_1.zip
	又发现一个问题，ldm to PC还只支持ARM 状态，不支持Thumb状态
	存为sARM01_08_29_2.zip
	
2	支持了回写spsr_mode to cpsr，存为sARM01_08_29_3.zip
3	寄存器文件支持了对user bank 的访问，存为sARM01_08_29_4.zip
4	ALUMisc[16]定义为访问user bank，已经完成代码的编写，并改正语法错误，但是还没有写测试程序，存为sARM01_08_29_5.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 8 30
1	完成了递增ldm的设计，测试通过，存为sARM01_08_30_1.zip
	还有以下问题
==	1	当有跳转时，必须清除decoder中的状态
	2	中断不理会整个流水线的状态，直接进入，会导致正在译码的指令的中断，应该先判断当前译码指令是否已经完成。
==	3	ldm to pc时必须考虑ARM和Thumb状态对低两位地址的影响
==	4	整个设计中存在Z值。
	5	选择0和4应该使用IfCurrentRegAccessByLDMSTM作为表达式的一部分
==	6	stm pc
	
2	完成了STM的支持，无语法错，存为sARM01_08_30_2.zip
3	终于通过测试，完全无错，存为sARM01_08_30_3.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 8 31
1	支持了LDM to PC under thumb 正在测试，ARM状态下的已经测试通过，存为sARM01_08_31_1.zip
==	但是，Thumb 状态下还没有支持
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 1
1	发现Thumb/ARM之间的转换只可能出现在BX和异常进入和退出时，只能是在ALUShell阶段，改正完成可以运行tblock例子，存为sARM01_09_01_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 3
1	处理了8 30的问题1，存为sARM01_09_03_1.zip
2	改为使用Wishbone，注意敏感表的问题，同时还有仲裁器输出的使用，还有存储器的有效Byte，存为sARM01_09_03_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 4
1	改正了所有的语法错误，存为sARM01_09_04_1.zip
2	仍然存在错误，存为sARM01_09_04_2.zip
3	终于可以支持wishbone了，存为sARM01_09_04_3.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 5
1	去掉设计中的Z，改正语法错误并存为sARM01_09_05_1.zip
2	成功的运行了所有的testbench，存为sARM01_09_05_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 6
1	ALUMisc[17]定义为MULL和MULA的signed or unsigned位，改正了所有错误，存为sARM01_09_06_1.zip
2	已经可以运行unsigned mull，存为sARM01_09_06_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 8
1	问题：读寄存器文件是不需要考虑特殊的状态的
2	修改了整体文件结构，存为sARM01_09_08_1.zip
3	修改了整体目录结构，存为sARM01_09_08_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 9
1	将乘法器的function去掉，得到被quartus接受的描述，存为sARM01_09_10_1.zip
2	decoder存在问题，
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 11
1	问题：应该将译码器中的left right third register 替换为位数
2	还差ALUComb和ALUShell中没有支持MLAL。存为sARM01_09_11_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 12
1	无语法错，存为sARM01_09_12_1.zip
2	已经将11日问题1解决，无语法错，存为sARM01_09_12_2.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 13
1	正在测试长乘加，但是有问题，存为sARM01_09_13_1.zip
2	原来是乘法器的第二个乘法联有问题，存为sARM01_09_13_2.zip
3	译码器的ALU指令译码会把BX译成ALU，改后存为sARM01_09_13_3.zip，以后记得一定要进行全面测试
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 14
1	问题：
	1	中断不顾整个流水线状态，直接进入，不行
	2	译码器会把某些指令译成ALU，注意测试
	3	译码器中存在寄存器域（4位）和寄存器常量的(8位)比较，应该改正。
2	ALUMisc[19:18]定义为half word transfer的类型
3	mem段中需要将BW替换成一个4位的选择码，以和wishbone结合
4	已经支持half word transfer，无语法错存为sARM01_09_14_2.zip
	测试进行到loadcon
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 15
1	已经经过了全面的测试，但是还没有测half word transfer，存为sARM01_09_15_1.zip
2	half word transfer已经可以了，存为sARM01_09_15_2.zip
3	ALUMisc[20]作为SWP的Byte/word标志
4	已经加入对SWP的支持，检查无语法错，存为sARM01_09_15_2.zip
5	已经检查过，发现即使是内存内容也是对的，存为sARM01_09_15_4.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 19
1	改动以增加一级流水，语法无错，存为sARM01_09_19_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 20
1	每一级的能否前进信号和输出有效信号都单独给出，以便下一级判断，每一级都不依赖于上一级来决定自己的前进，存为sARM01_09_20_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 21
1	已经完成5级流水，测试通过，存为sARM01_09_21_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 9 23
1	昨天完成了CDO指令，但是协处理器还没有，所以暂时不能用，存为sARM01_09_23_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 10 30
1	FIQ进入之后应该disable FIQ和IRQ，irq进入后则仅disable IRQ,没有测试存为sARM01_10_30_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 10 31
1	改正了I_Bus2Core中的有关reset的错误，存为sARM01_10_31_1.zip
--------------------------------------------------------------------------

--------------------------------------------------------------------------
2001 11 1
1	增加了conmax以代替wishbone互联,测试无错,存为sARM01_11_1_1.zip
2	增加了中断控制器,没有测试,存为sARM01_11_1_2.zip
3	修改了中断产生的机制,在有状态的情况下就不会产生中断.测试没有语法错,存为sARM01_11_1_3.zip
--------------------------------------------------------------------------
